//go:build ignore

package main

import (
	"archive/zip"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"strings"
)

const template = "" +
	"// Code generated by genembed.go; DO NOT EDIT.\n\n" +
	"package %s\n" +
	"import _ \"embed\"\n" +
	"//go:embed %s\n" +
	"var archive []byte"

func fatalf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}

func main() {
	url := flag.String("url", "", "URL of zip archive to download")
	name := flag.String("name", "", "output zip filename to create and embed (e.g. assets.zip)")
	flag.Parse()

	if *url == "" || *name == "" {
		fmt.Fprintln(os.Stderr, "required: -url and -name")
		flag.Usage()
		os.Exit(2)
	}

	if _, err := os.Stat(*name); errors.Is(err, os.ErrNotExist) {
		err := produceArchive(*url, *name)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
	} else {
		fmt.Printf("%s already exists\n", *name)
	}

	pkg := os.Getenv("GOPACKAGE")
	src := fmt.Sprintf(template, pkg, *name)

	fmtSrc, err := format.Source([]byte(src))
	if err != nil {
		fmt.Fprintf(os.Stderr, "warning: gofmt failed: %w â€” writing unformatted source\n", err)
		os.Exit(2)
	}

	if err := os.WriteFile("embed_archive.go", fmtSrc, 0o644); err != nil {
		fatalf("write generated go file: %v", err)
	}
}

func produceArchive(url, name string) error {
	fmt.Println("downloading license archive")
	b, err := downloadToMemory(url)
	if err != nil {
		return fmt.Errorf("download: %w", err)
	}

	zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return fmt.Errorf("open zip: %w", err)
	}

	// Create new zip in memory, collecting files from "text/" directory
	outBuf := &bytes.Buffer{}
	zw := zip.NewWriter(outBuf)

	for _, f := range zr.File {
		n := f.Name

		p := strings.Split(n, "/")

		// We only want entries under "<archive name>/text/"
		if len(p) != 3 {
			continue
		}
		if p[1] != "text" {
			continue
		}

		// compute new name: remove .txt suffix if present
		newName := p[2]
		newName = strings.TrimSuffix(newName, ".txt")

		// prepare header using original file header as much as possible
		rc, err := f.Open()
		if err != nil {
			return fmt.Errorf("open entry %s: %w", f.Name, err)
		}
		data, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			return fmt.Errorf("read entry %s: %w", f.Name, err)
		}

		h := &zip.FileHeader{
			Name:   newName,
			Method: zip.Deflate,
		}

		w, err := zw.CreateHeader(h)
		if err != nil {
			fatalf("create header %s: %v", newName, err)
			return fmt.Errorf("create header %s: %w", newName, err)
		}
		if _, err := w.Write(data); err != nil {
			return fmt.Errorf("write data %s: %w", newName, err)
		}
	}

	if err := zw.Close(); err != nil {
		fatalf("close new zip: %v", err)
		return fmt.Errorf("close new zip: %w", err)
	}

	if err := os.WriteFile(name, outBuf.Bytes(), 0o644); err != nil {
		fatalf("write output zip %s: %v", name, err)
		return fmt.Errorf("write output zip %s: %w", name, err)
	}

	return nil
}

// downloadToMemory GETs url and returns body as []byte
func downloadToMemory(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return nil, fmt.Errorf("http status: %s", resp.Status)
	}
	return io.ReadAll(resp.Body)
}
